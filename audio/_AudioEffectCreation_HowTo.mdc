---
description: 
globs: *.sc
alwaysApply: false
---
# SuperCollider Effect SynthDef Guide for Master Analysis Integration

This guide outlines the required structure for SuperCollider effect `SynthDefs` within the BICE-Box project to ensure proper integration with the centralized `masterAnalyser` node defined in [init.sc]. The goal is to have `masterAnalyser` handle all waveform, FFT, and RMS analysis, as well as the sending of the `/combined_data` OSC message.

Individual effect `SynthDefs` should focus *solely* on their unique audio processing.

## 1. SynthDef Arguments

All effect `SynthDefs` must include the following arguments in their definition:

```supercollider
SynthDef(\yourEffectName, {
    |
    out = 0,                 // Main audio output bus (e.g., to speakers)
    in_bus,                  // Input audio bus (connected to ~input_bus from init.sc)
    analysis_out_bus,        // Dedicated mono output bus for masterAnalyser
    // ... your effect-specific parameters (e.g., mix, rate, depth) ...
    |

    // ... rest of your SynthDef code ...
}).add;
```

## 2. Core Responsibilities

### a. Audio Input
- Read the incoming audio signal from the `in_bus`:
  ```supercollider
  var sig = In.ar(in_bus); // Or In.ar(in_bus, num_channels_expected)
  ```

### b. Audio Processing
- Implement your effect's unique sound manipulation logic using the `sig` variable.

### c. Output Signal Preparation
- **Main Output:** Prepare your final processed signal (can be mono or stereo).
  ```supercollider
  var final_processed_signal = ... ; // Your processed audio
  ```
- **Analysis Output:** Create a **mono** version of your `final_processed_signal`. This is crucial for `masterAnalyser`.
  ```supercollider
  var mono_for_analysis;
  if (final_processed_signal.isArray) { // Check if stereo
      mono_for_analysis = Mix.ar(final_processed_signal); // Mix stereo to mono
  } {
      mono_for_analysis = final_processed_signal; // Already mono
  };
  ```
  Alternatively, if your signal path naturally produces a mono sum at some point, you can use that.

### d. Audio Output
- Send the main processed signal to the `out` bus:
  ```supercollider
  Out.ar(out, final_processed_signal);
  ```
- Send the dedicated mono signal for analysis to the `analysis_out_bus`:
  ```supercollider
  Out.ar(analysis_out_bus, mono_for_analysis);
  ```

## 3. Forbidden Operations (for OSC Data Generation)

Effect `SynthDefs` **MUST NOT** duplicate the analysis and OSC message generation handled by `masterAnalyser`. Specifically, avoid the following *for the purpose of sending data intended for the main UI visualization via `/combined_data` or similar primary OSC paths*:

- `Phasor.ar` or `Sweep.ar` for buffer indexing *if its intent is to replicate `masterAnalyser`'s waveform segmentation for OSC*.
- `BufWr.ar` for writing waveform data to global buffers like `~relay_buffer_out` or `~relay_buffer_in` *if this data is meant for the primary waveform display sent by `masterAnalyser`*.
- `FFT.ar` for performing Fast Fourier Transform and writing to global FFT buffers *if this data is meant for the primary FFT display sent by `masterAnalyser`*.
- `RunningSum.rms` or similar for RMS calculation *if the result is intended to be sent as the primary input/output RMS values for the UI*.
- `SendReply.kr` for sending OSC messages that `masterAnalyser` is already responsible for (e.g., `/combined_data`, or older paths like `/buffer_refresh`, `/rms`, `/fft_data` that were part of the combined data package).
- `Out.kr` for writing RMS values to global control buses like `~rms_bus_input` or `~rms_bus_output` *as these are now exclusively managed by `masterAnalyser`*.

**Clarification:** Effects are free to use `BufWr.ar`, `FFT.ar`, `RunningSum.rms`, etc., for their *own internal audio processing needs* (e.g., creating a delay line, a spectral processing effect, an internal LFO based on amplitude). The restriction applies only to duplicating the specific analysis tasks and OSC message generation that `masterAnalyser` now centrally manages for the UI.

## 4. Synth Instantiation (in the .sc file that loads the SynthDef)

When the effect Synth is created (typically when its `.sc` file is evaluated), it must be instantiated with the correct bus arguments and target group:

```supercollider
// ... inside your effect's .sc file, after the SynthDef.add ...
fork {
    s.sync;
    if(~effect.notNil, { ~effect.free; }); // Free previous effect

    ~effect = Synth(\yourEffectName, [
        \in_bus, ~input_bus, // ~input_bus is defined in init.sc
        \analysis_out_bus, ~effect_output_bus_for_analysis, // This bus is defined in init.sc
        // ... other parameters ...
        \your_param_1, default_value_1,
        \your_param_2, default_value_2
    ], ~effectGroup); // ~effectGroup is defined in init.sc
    ("New YourEffectName synth created with analysis output bus").postln;
};
```

## 5. Examples

Refer to the following refactored effects for practical examples:
- [bypass.sc](mdc:bice-box/bice-box/bice-box-effects/audio/bypass.sc)
- [crackle_reverb.sc](mdc:bice-box/bice-box/bice-box-effects/audio/crackle_reverb.sc)

By adhering to this structure, effects will seamlessly integrate into the centralized analysis system, simplifying their individual code and ensuring consistent data for visualization.

## Appendix A: Notes for Automated Code Generation/Editing

This appendix provides guidance for tools or scripts that automatically generate or modify SuperCollider `.sc` files, particularly concerning symbol notation.

### A.1. Symbol Notation for `SynthDef` and `Synth`

In SuperCollider, symbols are denoted with a single preceding backslash (e.g., `\myEffectName`). When code is generated or edited programmatically (e.g., by an AI assistant or a script), it is crucial that the final text written to the `.sc` file adheres strictly to this syntax.

**Correct Syntax in `.sc` file:**
```supercollider
SynthDef(\myEffect, { /* ... */ });
~effect = Synth(\myEffect, [/* arguments */], ~effectGroup);
```

**Common Pitfalls (Resulting in Incorrect Syntax in `.sc` file):**
If the code generation process involves creating string literals that are then written to a file, incorrect escaping can lead to errors:

*   **Over-escaping:** Producing `SynthDef(\\\\myEffect, ...)` or `Synth(\\\\myEffect, ...)` in the file. While SuperCollider might sometimes tolerate `\\symbol` (interpreting it as `\symbol`), multiple backslashes beyond that are usually errors or not best practice.
*   **Quote-escaping issues:** Producing `SynthDef(\\'myEffect\\', ...)` if quotes and backslashes are confused during string manipulation.

**Guideline for Automated Tools:**
When providing code to an editing tool (like specifying a `code_edit` string), ensure the string *itself* represents the exact, correct SuperCollider syntax that should appear in the file. For example, if an intermediate programming language requires backslashes to be escaped within its own string literals (e.g., a Python string `SynthDef(\\\\myEffect, ...)` to represent the SuperCollider code `SynthDef(\myEffect, ...)`), the tool using this string must correctly unescape it before writing to the `.sc` file, or the initial string must be crafted such that the final output is `SynthDef(\myEffect, ...)`. The primary goal is that the `.sc` file contains clean, standard SuperCollider syntax with single backslashes for symbols.

## 6. JSON Metadata File (.json)

Alongside each SuperCollider effect (`.sc` file), a corresponding JSON metadata file (`.json`) must be created. This file describes the effect and its parameters for the user interface.

**File Naming:** The JSON filename must exactly match the SuperCollider filename, but with a `.json` extension (e.g., `my_effect.sc` and `my_effect.json`).
Prefer `lowercase_snake_case` for actual filenames. This `lowercase_snake_case` base filename is also critical for the `SynthDef` name and the `audio` path within the JSON.

**Structure:**

```json
{
  "name": "User Friendly Effect Name", // e.g., "Gritty Distortion", "Shimmering Reverb"
  "description": "A brief description of what the effect does.",
  "audio": "audio/effect_filename.sc", // Path to the SuperCollider audio file
  "visual": "visual/oscilloscope.js", // Default for general audio effects
  "shader": "shaders/your_shader.glsl", // Optional: Path to a GLSL shader file or a JSON config for a multipass shader
  "params": [
    // Parameters array
  ]
}
```

-   **`name` (string):**
    -   This should be a user-friendly, "pretty" name for the effect, suitable for display in the UI (e.g., "Green Machine", "Crackle Reverb").
    -   This is distinct from the `SynthDef` name and the filename, which must be `lowercase_snake_case`.
-   **`description` (string):**
    -   A short (1-2 sentences) description of the effect's sound or behavior.
-   **`audio` (string):**
    -   The relative path to the SuperCollider audio effect file. This MUST follow the format `audio/FILENAME.sc`, where `FILENAME.sc` is the `lowercase_snake_case` name of the generated SuperCollider file (e.g., if the file is `gritty_baxandall_distortion.sc`, this field is `"audio/gritty_baxandall_distortion.sc"`).
-   **`visual` (string):**
    -   Path to a JavaScript visualization file. For all new audio effects primarily driven by SuperCollider, this field **MUST** be set to `"visual/oscilloscope.js"`. If the effect is primarily shader-based, this might be null or point to a different visualizer.
-   **`shader` (string, optional):**
    -   The relative path to a GLSL shader file (e.g., `"shaders/my_shader.glsl"`).
    -   Alternatively, this can be a path to a JSON file that defines a multi-pass shader pipeline (e.g., `"shaders/my_multipass_config.json"`).
    -   If the effect does not use a custom shader, this field can be omitted or set to `null`.
-   **`params` (array of objects):**
    -   This array defines the controllable parameters of the effect that will be exposed to the UI.
    -   Each object in the array represents one parameter and corresponds to an argument in the `SynthDef` (excluding standard arguments like `out`, `in_bus`).
    -   The order of parameters in this array should ideally match their declaration order in the `SynthDef` for consistency.

    **Parameter Object Structure:**
    ```json
    {
      "name": "paramName",   // Exact match to SynthDef argument name (e.g., "drive", "bass")
      "value": 0.5,          // Initial/default value (must match SynthDef default)
      "range": [0.0, 1.0]    // Array with two numbers: [minimumValue, maximumValue]
      // "type": "float",    // Type is implicitly float/numeric for ParamFader
      // "step": 0.01,       // (Future UI enhancement) Value increment step
      // "unit": "Hz",         // (Future UI enhancement) Unit label
    }
    ```
    -   **`name` (string):** The exact name of the argument as defined in the `SynthDef` (e.g., `delayTime`, `feedbackGain`, `mix`).
    -   **`value` (number):** The initial (default) value for the parameter. This **MUST** match the default value specified in the `SynthDef` arguments.
    -   **`range` (array of two numbers):** An array specifying `[minimumValue, maximumValue]` for the parameter.

    **Standard Parameters:**
    -   If the `SynthDef` includes a `mix = 0.5` argument (for wet/dry control), it should be last in the list of parameters and its corresponding entry in the `params` array should be:
        ```json
        {
          "name": "mix",
          "value": 0.5,
          "range": [0.0, 1.0]
        }
        ```
    -   Standard arguments like `out` and `in_bus` should **NOT** be included in the `params` array.

**Example `params` entry for a `rate` argument in a `SynthDef` like `rate = 1.0` (assuming it ranges from 0.1 to 20 Hz):**
```json
{
  "name": "rate",
  "value": 1.0,
  "range": [0.1, 20.0]
}
```
